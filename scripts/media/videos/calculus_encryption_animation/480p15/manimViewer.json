{
    "CalculusEncryptionAnimation": "class CalculusEncryptionAnimation(Scene):\n    def construct(self):\n        self.logic_intro()\n        self.render_mathematical_base()\n        self.execute_encryption_transform()\n        self.process_visual_mapping()\n        self.execute_decryption_transform()\n        self.display_algorithm_implementation()\n        self.render_complete_system()\n    def logic_intro(self):\n        primary_title = MathTex(r\"\\text{Calculus-Based Encryption}\", font_size=72)\n        primary_title.set_color_by_gradient(BLUE, PURPLE, RED)\n        secondary_title = MathTex(r\"\\text{Where Mathematics Meets Cryptography}\", font_size=36)\n        secondary_title.set_color(GRAY)\n        secondary_title.next_to(primary_title, DOWN, buff=0.5)\n        mathematical_symbols = VGroup()\n        symbol_list = [r\"\\int\", r\"\\frac{d}{dx}\", r\"\\sum\", r\"\\lim\", r\"\\nabla\"]\n    def render_mathematical_base(self):\n        foundation_header = Text(\"Calculus-Based Encryption\", font_size=48)\n        foundation_header.set_color(BLUE)\n        foundation_header.to_edge(UP)\n        self.play(Write(foundation_header))\n        encryption_formula = MathTex(\n            r\"E(x) = \\int_0^x f'(t) \\cdot g(t) \\, dt + C\",\n            font_size=60\n        )\n        encryption_formula.set_color_by_tex_to_color_map({\n            \"E(x)\": RED,\n            \"f'(t)\": BLUE,\n            \"g(t)\": GREEN,\n            \"C\": PURPLE\n        })\n        encryption_formula.move_to(UP * 1.5)\n        decryption_formula = MathTex(\n            r\"D(y) = \\frac{d}{dx}\\left[\\frac{y - C}{g(x)}\\right]\",\n            font_size=60\n        )\n        decryption_formula.set_color_by_tex_to_color_map({\n            \"D(y)\": RED,\n            \"y\": ORANGE,\n            \"C\": PURPLE,\n            \"g(x)\": GREEN\n        })\n        decryption_formula.move_to(ORIGIN)\n        key_generation_formula = MathTex(\n            r\"K = \\sum_{n=1}^{\\infty} \\frac{(-1)^n}{n!} \\left(\\frac{x}{a}\\right)^n\",\n            font_size=50\n        )\n        key_generation_formula.set_color(YELLOW)\n        key_generation_formula.move_to(DOWN * 1.5)\n        self.play(Write(encryption_formula), run_time=2)\n        self.wait(1)\n        self.play(Write(decryption_formula), run_time=2)\n        self.wait(1)\n        self.play(Write(key_generation_formula), run_time=2)\n        connection_arrow_1 = Arrow(encryption_formula.get_bottom(), decryption_formula.get_top(), color=YELLOW)\n        connection_arrow_2 = Arrow(decryption_formula.get_bottom(), key_generation_formula.get_top(), color=YELLOW)\n        self.play(Create(connection_arrow_1), Create(connection_arrow_2))\n        self.wait(2)\n        self.play(\n            FadeOut(foundation_header),\n            FadeOut(encryption_formula),\n            FadeOut(decryption_formula),\n            FadeOut(key_generation_formula),\n            FadeOut(connection_arrow_1),\n            FadeOut(connection_arrow_2)\n        )\n    def execute_encryption_transform(self):\n        process_header = Text(\"Encryption Process\", font_size=48)\n        process_header.set_color(RED)\n        process_header.to_edge(UP)\n        self.play(Write(process_header))\n        coordinate_system = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-2, 4, 1],\n            x_length=8,\n            y_length=6,\n            axis_config={\"color\": WHITE}\n        )\n        coordinate_system.move_to(LEFT * 1)\n        original_function = coordinate_system.plot(lambda x: x**2, color=BLUE, x_range=[-2, 2])\n        original_label = MathTex(r\"f(x) = x^2\", color=BLUE, font_size=36)\n        original_label.move_to(RIGHT * 4 + UP * 2)\n        key_function = coordinate_system.plot(lambda x: np.sin(2*x), color=GREEN, x_range=[-2, 2])\n        key_label = MathTex(r\"g(x) = \\sin(2x)\", color=GREEN, font_size=36)\n        key_label.move_to(RIGHT * 4 + UP * 1)\n        self.play(Create(coordinate_system))\n        self.play(Create(original_function), Write(original_label))\n        self.play(Create(key_function), Write(key_label))\n        derivative_function = coordinate_system.plot(lambda x: 2*x, color=PURPLE, x_range=[-2, 2])\n        derivative_label = MathTex(r\"f'(x) = 2x\", color=PURPLE, font_size=36)\n        derivative_label.move_to(RIGHT * 4 + ORIGIN)\n        self.play(Create(derivative_function), Write(derivative_label))\n        product_function = coordinate_system.plot(lambda x: 2*x * np.sin(2*x), color=ORANGE, x_range=[-2, 2])\n        product_label = MathTex(r\"f'(x) \\cdot g(x) = 2x\\sin(2x)\", color=ORANGE, font_size=32)\n        product_label.move_to(RIGHT * 4 + DOWN * 1)\n        self.play(\n            Transform(derivative_function, product_function),\n            Transform(derivative_label, product_label)\n        )\n        encrypted_function = coordinate_system.plot(\n            lambda x: -x*np.cos(2*x) + 0.5*np.sin(2*x),\n            color=RED,\n            x_range=[-2, 2]\n        )\n        encrypted_label = MathTex(\n            r\"E(x) = \\int 2x\\sin(2x) dx\",\n            color=RED,\n            font_size=32\n        )\n        encrypted_label.move_to(RIGHT * 4 + DOWN * 2)\n        self.play(\n            Transform(product_function, encrypted_function),\n            Transform(product_label, encrypted_label)\n        )\n        self.wait(2)\n        self.play(\n            FadeOut(process_header),\n            FadeOut(coordinate_system),\n            FadeOut(original_function),\n            FadeOut(key_function),\n            FadeOut(derivative_function),\n            FadeOut(product_function),\n            FadeOut(original_label),\n            FadeOut(key_label),\n            FadeOut(derivative_label),\n            FadeOut(product_label)\n        )\n    def process_visual_mapping(self):\n        transform_header = Text(\"Visual Transformation\", font_size=48)\n        transform_header.set_color(PURPLE)\n        transform_header.to_edge(UP)\n        self.play(Write(transform_header))\n        plaintext_input = Text(\"HELLO\", font_size=72)\n        plaintext_input.set_color(BLUE)\n        plaintext_input.move_to(LEFT * 4)\n        transform_operator = Arrow(LEFT * 2, RIGHT * 2, color=YELLOW, buff=0.5)\n        transform_notation = MathTex(r\"\\mathcal{F}[\\cdot]\", font_size=48)\n        transform_notation.next_to(transform_operator, UP)\n        transform_notation.set_color(YELLOW)\n        ciphertext_output = VGroup()\n        encrypted_values_list = [\n            MathTex(r\"2.718\", color=RED),\n            MathTex(r\"3.141\", color=RED),\n            MathTex(r\"1.414\", color=RED),\n            MathTex(r\"1.732\", color=RED),\n            MathTex(r\"2.236\", color=RED)\n        ]\n        for i, value_tex in enumerate(encrypted_values_list):\n            value_tex.move_to(RIGHT * 4 + UP * (1 - i * 0.5))\n            ciphertext_output.add(value_tex)\n        self.play(Write(plaintext_input))\n        self.play(Create(transform_operator), Write(transform_notation))\n        for i, char in enumerate(plaintext_input):\n            self.play(\n                char.animate.set_color(YELLOW).scale(1.2),\n                run_time=0.3\n            )\n            self.play(\n                char.animate.set_color(RED).scale(0.8),\n                Write(encrypted_values_list[i]),\n                run_time=0.5\n            )\n        mathematical_operations = VGroup()\n        operation_symbols = [r\"+\", r\"\\times\", r\"\\int\", r\"\\frac{d}{dx}\"]\n        for i, op_symbol in enumerate(operation_symbols):\n            operation = MathTex(op_symbol)\n            operation.set_color(ORANGE)\n            operation.move_to(UP * 2 + RIGHT * (i - 1.5))\n            mathematical_operations.add(operation)\n        self.play(*[Write(op) for op in mathematical_operations])\n        self.wait(2)\n        self.play(FadeOut(mathematical_operations))\n        self.wait(2)\n        self.play(\n            FadeOut(transform_header),\n            FadeOut(plaintext_input),\n            FadeOut(transform_operator),\n            FadeOut(transform_notation),\n            FadeOut(ciphertext_output)\n        )\n    def execute_decryption_transform(self):\n        decrypt_header = Text(\"Decryption Process\", font_size=48)\n        decrypt_header.set_color(GREEN)\n        decrypt_header.to_edge(UP)\n        self.play(Write(decrypt_header))\n        encrypted_input_data = VGroup()\n        input_values = [2.718, 3.141, 1.414, 1.732, 2.236]\n        for i, value in enumerate(input_values):\n            numerical_display = DecimalNumber(value, num_decimal_places=3, color=RED)\n            numerical_display.move_to(LEFT * 4 + UP * (1 - i * 0.5))\n            encrypted_input_data.add(numerical_display)\n        inverse_transform_operator = Arrow(LEFT * 2, RIGHT * 2, color=TEAL, buff=0.5)\n        inverse_notation = MathTex(r\"\\mathcal{F}^{-1}[\\cdot]\", font_size=48)\n        inverse_notation.next_to(inverse_transform_operator, UP)\n        inverse_notation.set_color(TEAL)\n        decrypted_output = Text(\"HELLO\", font_size=72)\n        decrypted_output.set_color(BLUE)\n        decrypted_output.move_to(RIGHT * 4)\n        self.play(*[Write(num) for num in encrypted_input_data])\n        self.play(Create(inverse_transform_operator), Write(inverse_notation))\n        inverse_operations = VGroup()\n        inverse_operation_symbols = [r\"-\", r\"\\div\", r\"\\frac{d}{dx}\", r\"\\int\"]\n        for i, op_symbol in enumerate(inverse_operation_symbols):\n            operation = MathTex(op_symbol)\n            operation.set_color(TEAL)\n            operation.move_to(UP * 2 + RIGHT * (i - 1.5))\n            inverse_operations.add(operation)\n        self.play(*[Write(op) for op in inverse_operations])\n        self.wait(2)\n        self.play(FadeOut(inverse_operations))\n        for i, numerical_value in enumerate(encrypted_input_data):\n            self.play(\n                numerical_value.animate.set_color(TEAL).scale(1.2),\n                run_time=0.3\n            )\n            self.play(\n                numerical_value.animate.set_color(BLUE).scale(0.8),\n                run_time=0.5\n            )\n        self.play(Write(decrypted_output))\n        success_indicator = Text(\"âœ“ DECRYPTION SUCCESSFUL\", font_size=36, color=GREEN)\n        success_indicator.next_to(decrypted_output, DOWN, buff=1)\n        self.play(Write(success_indicator))\n        self.wait(2)\n        self.play(\n            FadeOut(decrypt_header),\n            FadeOut(encrypted_input_data),\n            FadeOut(inverse_transform_operator),\n            FadeOut(inverse_notation),\n            FadeOut(decrypted_output),\n            FadeOut(success_indicator)\n        )\n    def display_algorithm_implementation(self):\n        code_header = Text(\"Implementation\", font_size=48)\n        code_header.set_color(ORANGE)\n        code_header.to_edge(UP)\n        self.play(Write(code_header))\n        encryption_algorithm = Text(\n            \"\"\"def encrypt(plaintext, key_func):\n    result = []\n    for i, char in enumerate(plaintext):\n        val = ord(char)\n        derivative = differentiate(val, i)\n        integral = integrate(derivative * key_func(i))\n        encrypted = integral + math.e ** (i % 3)\n        result.append(encrypted)\n    return result\"\"\",\n            font_size=20,\n            color=WHITE,\n            font=\"Courier\"\n        )\n        encryption_algorithm.scale(0.8)\n        encryption_algorithm.move_to(LEFT * 3)\n        decryption_algorithm = Text(\n            \"\"\"def decrypt(ciphertext, key_func):\n    result = []\n    for i, encrypted_val in enumerate(ciphertext):\n        val = encrypted_val - math.e ** (i % 3)\n        derivative = differentiate(val / key_func(i))\n        original = integrate_inverse(derivative)\n        char = chr(int(original))\n        result.append(char)\n    return ''.join(result)\"\"\",\n            font_size=20,\n            color=WHITE,\n            font=\"Courier\"\n        )\n        decryption_algorithm.scale(0.8)\n        decryption_algorithm.move_to(RIGHT * 3)\n        self.play(Write(encryption_algorithm), run_time=3)\n        self.play(Write(decryption_algorithm), run_time=3)\n        highlight_encryption = Rectangle(width=2, height=0.5, color=YELLOW)\n        highlight_encryption.move_to(encryption_algorithm.get_center() + UP * 0.5)\n        highlight_decryption = Rectangle(width=2, height=0.5, color=TEAL)\n        highlight_decryption.move_to(decryption_algorithm.get_center() + UP * 0.5)\n        self.play(Create(highlight_encryption), Create(highlight_decryption))\n        self.wait(2)\n        self.play(\n            FadeOut(code_header),\n            FadeOut(encryption_algorithm),\n            FadeOut(decryption_algorithm),\n            FadeOut(highlight_encryption),\n            FadeOut(highlight_decryption)\n        )\n    def render_complete_system(self):\n        final_header = Text(\"Complete Demonstration\", font_size=48)\n        final_header.set_color_by_gradient(RED, BLUE, GREEN)\n        final_header.to_edge(UP)\n        self.play(Write(final_header))\n        input_container = Rectangle(width=2, height=1, color=BLUE)\n        input_label = Text(\"INPUT\", font_size=24, color=WHITE)\n        input_label.move_to(input_container.get_center())\n        input_module = VGroup(input_container, input_label)\n        input_module.move_to(LEFT * 5)\n        mathematical_processor = Rectangle(width=3, height=2, color=PURPLE)\n        mathematical_formulas = VGroup(\n            MathTex(r\"\\frac{d}{dx}\", font_size=20),\n            MathTex(r\"\\int\", font_size=20),\n            MathTex(r\"\\sum\", font_size=20),\n            MathTex(r\"e^x\", font_size=20)\n        )\n        mathematical_formulas.arrange(DOWN, buff=0.1)\n        mathematical_formulas.move_to(mathematical_processor.get_center())\n        processor_module = VGroup(mathematical_processor, mathematical_formulas)\n        processor_module.move_to(ORIGIN)\n        output_container = Rectangle(width=2, height=1, color=RED)\n        output_label = Text(\"OUTPUT\", font_size=24, color=WHITE)\n        output_label.move_to(output_container.get_center())\n        output_module = VGroup(output_container, output_label)\n        output_module.move_to(RIGHT * 5)\n        flow_arrow_1 = Arrow(input_module.get_right(), processor_module.get_left(), color=YELLOW)\n        flow_arrow_2 = Arrow(processor_module.get_right(), output_module.get_left(), color=YELLOW)\n        security_indicators = VGroup()\n        for i in range(8):\n            security_symbol = MathTex(r\"\\infty\", font_size=20, color=YELLOW)\n            angle_pos = i * PI / 4\n            security_symbol.move_to(2 * np.array([np.cos(angle_pos), np.sin(angle_pos), 0]))\n            security_indicators.add(security_symbol)\n        self.play(\n            Create(input_module),\n            Create(processor_module),\n            Create(output_module)\n        )\n        self.play(Create(flow_arrow_1), Create(flow_arrow_2))\n        self.play(*[Create(symbol) for symbol in security_indicators])\n        self.wait(2)\n        final_security_equation = MathTex(\n            r\"\\text{Algorithm} = \\lim_{n \\to \\infty} \\sum_{k=1}^{n} \\frac{1}{k!} \\left(\\frac{\\partial^k f}{\\partial x^k}\\right)^2\",\n            font_size=40\n        )\n        final_security_equation.set_color_by_gradient(BLUE, PURPLE, RED)\n        final_security_equation.next_to(processor_module, DOWN, buff=1)\n        self.play(Write(final_security_equation), run_time=3)\n        self.play(Write(conclusion_statement))\n        self.wait(3)\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=2\n        )"
}